# Handlers*
Важно: это необязательная задача, её выполнение не влияет на получение зачёта.

## Легенда
Сервер, который вы написали в предыдущей задаче, - это, конечно, здорово, но пока он не расширяем и его нельзя переиспользовать, т.к. код обработки зашит прямо внутрь сервера.

Давайте попробуем его сделать немного полезнее.

Что хотим сделать? Мы хотим сделать так, чтобы в сервер можно было добавлять обработчики на определённые шаблоны путей.

Что это значит? Мы хотим, чтобы можно было сделать вот так:



      public class Main {
    public static void main(String[] args){
      final var server = new Server();  
      // код инициализации сервера (из вашего предыдущего ДЗ)
      
      // добавление handler'ов (обработчиков)    
      server.addHandler("GET", "/messages", new Handler() {
        public void handle(Request request, BufferedOutputStream responseStream) {
          // TODO: handlers code
        }
      });
      server.addHandler("POST", "/messages", new Handler() {
        public void handle(Request request, BufferedOutputStream responseStream) {
          // TODO: handlers code
        }
      });

      server.listen(9999);
    }
    }

В итоге на запрос типа GET на путь "/messages" будет вызван первый обработчик, на запрос типа POST и путь "/messages" будет вызван второй.

Как вы видите - Handler из себя представляет функциональный интерфейс всего с одним методом (может быть заменён на lambda).

Request - это класс, который проектируете вы сами, для нас важно, чтобы он содержал:

Метод запроса (потому что на разные методы можно назначить один и тот же Handler)
Заголовки запроса
Тело запроса (если есть)
BufferedOutputStream берётся просто путём заворачивания OutputStream'а socket'а: new BufferedOutputStream(socket.getOutputStream()).

## Задача
Реализуйте требования, указанные в легенде.

### Подсказки по реализации
1. Вы принимаете запрос, парсите его целиком (как мы сделали на лекции) и собираете объект типа Request
2. На основании данных из Request вы выбираете handler (он может быть только один), который и будет обрабатывать запрос
3. Все handler'ы должны храниться в полях Server'а
4. Самый простой способ хранить handler'ы - это использовать в качестве ключей метод и путь (можно как сделать Map внутри Map, так и отдельные Map'ы на каждый метод)
5. Поиск хендлера заключается в том, что вы выбираете по нужному методу все зарегистрированные handler'ы, а затем перебираете по пути (используйте пока точное соответствие: считайте, что у вас все запросы без Query String)
6. Найдя нужный handler - достаточно вызвать его метод handle, передав туда Request и BufferedOutputStream
7. Поскольку ваш сервер многопоточный - думайте о том, как вы будете безопасно хранить handler'ы
8. В качестве Body достаточно передавать InputStream (напоминаем, Body начинается после \r\n\r\n

Итого: фактически вы решаете задачу поиска элемента в "коллекции" с вызовом его метода.

## Результат
Реализуйте новую функциональность в ветке feature/handlers вашего репозитория из ДЗ 1 и откройте Pull Request.

Поскольку вы - главный архитектор и проектировщик данного решения (уже более функционального), то все архитектурные решения принимать вам, но будьте готовы к критике со стороны проверяющих.

В качестве результата пришлите ссылку на ваш Pull Request на GitHub в личном кабинете студента на сайте netology.ru.

После того, как ДЗ будет принято, сделайте merge для Pull Request'а.
